
# 类加载机制

    类加载过程：  
        类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括:加载、验证、准备、解析、初始化、使用和卸载七个阶段。  
- 着重说一下加载  
    加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：  
    1.通过一个类的全限定名来获取其定义的二进制字节流。  
    2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  
    3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。  
    相对于类加载的其他阶段而言，加载阶段(加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，可以使用系统提供，而可以是自定义的类加载器来完成加载。  
    加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区(Method Area)中，而且在Java堆中也创建一个java.lang.Class的对象，这样就可以通过对象访问方法区中的这些数据。  
    **类加载器**  
    类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任何一个类，都需要由它的类加载器和这个类本身一同确定其在JVM中的唯一性，也就是说，`即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。`  
    站在JVM的角度来讲，只存在两种不同的类加载器：  
    - 启动类加载器：它使用C++实现(Hotspot)，是JVM自身的一部分； 
    - 所有其他的类加载器：这些类加载器都有Java语言实现，独立于JVM之外，并且全部继承自抽象类java.lang.ClassLoader,这些类加载器需要有启动类加载器加载到内存中之后才能去加载其他类。    
    站在开发的角度而言，类加载器大致可以分为三类：  
    - 启动类加载器：Bootstrap Classloader，负责加载存放在JDK/jre/lib下，或被-Xbootclasspath参数指定的路径中低端，并且能被虚拟机识别的类库。启动类加载器是无法被程序直接引用的。  
    - 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发人员可以直接使用扩展类加载器。  
    - 应用程序加载器：Application ClassLoader，有sun.misc.Launcher$AppClassLoader来实现，负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下就是程序中默认的类加载器。  
    **应用程序都是由这三中类加载器互相配合进行加载的，如果有必要，还可以加入自定义的ClassLoader。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件**  
![image](http://img.blog.csdn.net/20140105211242593) 
