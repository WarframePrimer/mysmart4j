Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

![image](https://raw.githubusercontent.com/WarframePrimer/mysmart4j/master/img/JVM.png)

## 1.PC寄存器
  JVM可以支持多线程同时执行，每一条JVM线程都有自己的pc(program counter)寄存器。在任意时刻，一条JVM虚拟机只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的`当前方法(current method)`。如果这个方法不是native的，pc寄存器就保存JVM正在执行的字节码指令的地址，如果该方法是native的，pc寄存器的值就是undefined。pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。
## 2.Java虚拟机栈
  每一个JVM线程都有自己私有的Java虚拟机栈，这个栈与线程同时创建，用于存储`栈帧(Frame)`。  
  Java虚拟机栈可以是固定大小，也可以根据计算动态来扩展和收缩。  
### 2.1 栈帧
  栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值和异常分派。  
  栈帧对着方法调用而创建，随着方法结束而销毁。
  栈帧的存储空间由创建它的线程分配在Java虚拟机栈中，每一个栈帧都有自己的`本地变量表(局部变量表)`、`操作数栈`和指向当前方法所属的类的运行时常量池的引用。
  栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一个线程的栈帧。
- 2.1.1 局部变量表
  每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译期决定，并且存储于类或接口的二进制表示之中  
  一个局部变量可以保存一个类型为`boolean`、`byte`、`char`、`short`、`int`、`float`、`reference`或`returnAddress`的数据;两个局部变量可以保存一个类型为`long`或`double`的数据。  
  局部变量使用索引来进行定位访问。首个局部变量的索引值为0。
  Java虚拟机使用局部变量表来完成方法调用时的`参数传递`。当调用类方法时，它的参数将会依次传递到局部变量表中(索引)从0开始的连续位置上。当调用实例方法时，第0个局部变量一定用来存储该实例方法所在对象的引用(Java中的this关键字<soga>)。后续的其他参数传递则会从1开始。  

- 2.1.2 操作数栈
  每个栈帧内部都包含一个称为操作数栈的LIFO栈。栈帧中操作数栈的最大深度有编译期决定。  
  栈帧在刚刚创建时，操作数栈是空的。Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈取走数据、操作数据以及把操作结果重新入栈。在调用方法时，操作数栈也用来准备调用方法的参数以及接收方法返回结果。  
  在任意时期，操作数栈都会有一个确定的栈深度，一个long或double类型的数据会占用两个单位的栈深度，其他类型则会占用一个单位的栈深度。  

- 2.1.3 动态链接
  每个栈帧内部都包含一个指向当前方法所在类型的`运行时常量池`的引用，以便对当前方法的代码实现动态链接。在class文件中，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示(Linux(?_?)), 动态链接的作用就是将这些以符号引用所表示的方法转换为对实际方法的直接引用。
## 3.Java堆
  在JVM中，堆是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。  
  Java堆在虚拟机启动的时候就被创建，它存储了GC所管理的各种对象，这些被管理对象无需也无法显示地销毁。  
  Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间是自动收缩。  
## 4.方法区
  在JVM中，方法区是可供各个线程共享的运行时内存区域。它存储了每一个类的结构信息，例如，运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。  
  方法区在虚拟机启动时创建，方法区是堆的逻辑组成部分。  
  方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间是自动收缩。
### 4.1 运行时常量池
  运行时常量池是class文件中每一个类或接口的常量池表的运行时表现形式，它包括了若干种不同的常量，从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用。  
  每一个运行时常量池在JVM的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。
## 5.本地方法栈
  本地方法栈：支持native方法(使用Java以外的语言编写的方法)执行的栈  
  一般在线程创建的时候按线程分配。
  
  
# 关于对象的访问
   由于reference类型在Java虚拟机规范中指规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问会有所不同，主流的访问方式有两种：`使用句柄`和`直接指针`。  
 - 如果使用`句柄访问`方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：
 ![image](https://github.com/WarframePrimer/mysmart4j/blob/master/img/newObject1.jpg)
 
 - 如果使用的是`直接指针访问`方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下如所示：
 ![image](https://github.com/WarframePrimer/mysmart4j/blob/master/img/newObject2.jpg)
 
 - 这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时(GC时移动对象是非常普遍的行为)只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的开销，由于对象的访问在Java中非常频繁，因次这类开销积少成多后也是一项非常可观的执行成本。
 
-----------
 
# Java垃圾收集器
```
GC需要完成的三件事情：
    哪些内存需要回收？
    什么时候回收?
    如何回收？
```
- 引用计数算法(具体就不细说了，原理很简单) Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。
- 根搜索算法(GC Roots Tracing) 这个算法的基本思路是通过一系列的名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，方一个对象到GC Roots没有任何引用链相连(从GC Roots到这个对象不可达)时，就证明此对象是不可用的。
```
 在Java语言中，可作为GC Roots的对象包括下面几种：
     虚拟机栈中的引用的对象；
     方法区中的类静态属性引用的对象；
     方法区中的常量引用的对象；
     本地方法栈中JNI的引用的对象。
```

## 引用？
   无论是通过引用计数算法还是根搜索算法，判断对象是否存货都是与‘引用’有关。在JDK1.2之前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址就称这块内存代表一个引用。这种定义过于绝对，没有回旋余地，对于一个对象只有被引用和没有被引用两种状态。  
   在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度一次逐渐减弱。
```
  强引用就是指在程序代码中普遍存在的，类似于`Object obj = new Object()`这类的引用，只要强引用还存在，GC就永远不会回收掉被引用的对象。
  软引用用来描述一些还有用，但并非必须的对象。对于软引用关联的对象，在系统将要发生OOM之前，将会把这些对象列进回收范围之中进行二次回收。
  弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。
  虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
  为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被GC回收是收到一个系统通知。
```

## 垃圾收集算法

### 分代收集算法
```
    当代商业虚拟机的GC都采用分代收集算法：
     将Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法
      在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，
       只需要付出少量存活对象的复制成本就可以完成收集。
      而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-整理算法
       或标记-清理算法来进行回收。
```

## 关于GC

Java中的堆是GC收集垃圾的主要区域。GC分为两种:Minor GC、Full GC。  
Minor GC是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有Java对象出生的地方，即Java对象申请的内存以及存放都是在这个地方。Java中的大部分对象通常不需长久存活，具有朝生夕灭的性质。  
当一个对象判定为‘死亡’的时候，GC就有责任来回收这部分对象的内存空间。新生代是GC收集垃圾的频繁区域。  
当对象在Eden(包括一个survivor)出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另外一块survivor所容纳，则使用复制算法将这些仍然还存活的对象复制到另外一块survivor区域中，然后清理所使用过的Eden以及survivor，并且将这些对象的年龄设置为1，以后对象在survivor中每熬过一次Minor GC，就将对象的年龄+1，当对象的年龄达到某个值时，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象则是直接进入老年代。  
Full GC是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。老年代里的对象几乎都是在survivor区域中熬过来的，它们是不会那么容易就‘死掉’了的。因此Full GC发生的次数不会有Minor GC那么频繁，并且做一次Full GC要比进行一次Minor GC的时间更长。  
另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片。此后需要为较大的对象分配内存空间时，若无法找到足够的连续内存空间，就会提前触发一次GC的收集动作。  

## JVM参数选项

|参数选项|相关信息|
|---|---|




 
 
 

