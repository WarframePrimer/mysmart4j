# Java并发工具包---java.util.concurrent(网上整理)
`并发包众多实现的基础：Java内存模型、volatile变量、AQS同步器`

- Java内存模型  
```
    内存模型的相关概念：计算机在执行程序时，每条指令都是在CPU中执行的，而在执行的过程中设计到数据的读取和写入。程序运行过程中的临时数据是存放在主存(RAM)中的，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度，因此CPU里面就有了高度缓存(Cache)。  
    也就是，在程序运行过程中，会将运算需要的数据从主存复制一份到CPU的高度缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到内存当中。
    指令重排序(Instruction Reorder):一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的一致，但是保证程序最终执行结果和代码顺序执行的结果是一样的。
    指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。要想并发程序正确的执行，必须要保证原子性、可见性和有序性。
```
    描述了线程内存和主存间的通讯关系。定义了线程内的内存改变将怎样传递到其他线程的规则，同样也定义了线程内存和主存进行同步的细节，也描述了哪些操作属于原子操作以及操作间的顺序。  
    java内存模型规定所有的变量都是存在主存当中(类似于物理内存RAM)，每个线程都有自己的工作内存(类似于高速缓存Cache)。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。  
    `代码顺序规则`：一个线程内的每个动作happens-before同一个线程内在代码顺序上在其后的所有动作。      
    `volatile变量规则`：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。  
    `传递性`：如果A happens-before B,B happens-before C,那么A happens-before C。   
    happens-before原则(先行发生原则)：  
    - `程序次序规则`：一个线程内，按照代码顺序，从执行结果上来看(书写在前面的顺序先行发生于书写在后面的操作)  
    - `锁定规则`：一个unLock操作先行发生于后面对用一个锁Lock操作  
    - `volatile变量规则`：对一个变量的写操作先行发生与后面对这个变量的读操作  
    - `传递规则`：如果A happens-before B,B happens-before C,那么A happens-before C。   
    - `线程启动规则`：Thread对象的start方法先行发生于此线程的每一个动作  
    - `线程中断规则`：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生  
    - `线程终结规则`：线程中所有的操作都先行发生于线程的终止检测  
    - `对象终结规则`：一个对象的初始化完成先行发生于他的finalize方法的执行
- volatile  
    当声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile:把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作进行了同步。  
    监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到对这个变量最后的写入。   
    volatile变量自身具有下列特性：  
        可见性：对一个volatile变量的读，总是能看到对这个变量最后的写入。   
        原子性：对任意单个volatile变量的读/写具有原子性，但类似volatile++这种复合操作不具有原子性。    
    volatile写和volatile读：  
        线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了(其对共享变量所在修改的)消息。  
        线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的(在写这个volatile变量之前对共享变量所做修改的) 消息。  
        线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上就是线程A通过主内存向线程B发送消息。  
    锁释放和锁获取：  
        线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的线程发出了(线程A对共享变量所做修改的)消息。   
        线程B获取一个锁，实质上是线程B接受了之前某个线程发出的(在释放锁之前对共享变量所做修改的)消息。  
        线程A释放锁，随后线程B获取这个锁，实质上是线程A通过主内存向线程B发送消息。  
    由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更具有优势。    
    
- AbstractQueueSynchronizer(AQS)

    AQS使用一个整型的volatile变量(state)来维护同步状态。

