
#### 事务的四大特性(ACID)
- A Atomicity 原子性
- C Consistency 一致性
- I Isolation 隔离性
- D Durability 持久性
#### 这四个特性是事务管理的基石：原子性是基础，隔离性是手段，持久性是目的，一致性是核心。

#### 事务隔离级别(Transaction Isolation Level) 从上往下，级别越来越高，并发性越来越差，安全性越来越高
- READ_UNCOMMITTED
- READ_COMMITTED
- REPEATABLE_READ
- SERIALIZABLE

#### 数据在高并发下产生的问题：
- Dirty Read(脏读);
- Unrepeatable Read(不可重复读);
- Phantom Read(幻读)。
---------
 `脏读数据` 
 
 |时间|事务A(存款)|事务B(取款)|
  |---|---|---|
  |T1|开始事务|——|
  |T2|——|开始事务|
  |T3|——|查询余额(1000元)|
  |T4|——|取出1000元(余额0元)|
  |T5|查询余额(0元)|——|
  |T6|——|撤销事务(余额恢复为1000元)|
  |T7|存入500元(余额500元)|——|
  |T8|提交事务|——|  
  
  `不可重复读`
  
|时间|事务A(存款)|事务B(取款)|
 |---|---|---|
 |T1|开始事务|——|
 |T2|——|开始事务|
 |T3|——|查询余额(1000元)|
 |T4|查询余额(1000元)|——|
 |T5|——|取出1000元(余额0元)|
 |T6|——|提交事务|
 |T7|查询余额(0元)|——|
 
 `幻读`
 
 |时间|事务A(统计总存款)|事务B(存款)|
 |---|---|---|
 |T1|开始事务|——|
 |T2|——|开始事务|
 |T3|统计总存款(10000元)|——|
 |T4|——|存入100元|
 |T5|——|提交事务|
 |T6|统计总存款(10100元)|——|
 
 ### 归纳一下，以上提到了事务并发所引起的读取数据有关的问题：
 - `脏读`——事务A读取了事务B未提交的数据，并在这个基础上有做了其他操作。
 - `不可重复读`——事务A读取了事务B已提交的更改数据。
 - `幻读`——事务A读取了事务B已提交的新增数据。
 
 `事务隔离级别`
 
 |事务隔离级别|脏读|不可重复读|幻读|
 |---|---|---|---|
 |READ_UNCOMMITTED|允许|允许|允许|
 |READ_COMMITTED|禁止|允许|允许|
 |REPEATABLE_READ|禁止|禁止|允许|
 |SERIALIZABLE|禁止|禁止|禁止|
 
 -----------
 
 ### Spring的事务传播行为(Transaction Propagation Behavior)  
 Spring一共提供了7种事务传播行为(假设事务从方法A传播到方法B，方法A有事务吗?)
 - PROPAGATION_REQUIRED;——————如果没有，新建一个事务;如果有，就加入当前事务(默认)
 - PROPAGATION_REQUIRED_NEW;——————如果没有，新建一个事务;如果有，将当前事务挂起
 - PROPAGATION_NESTED;——————如果没有，新建一个事务;如果有，在当前事务中嵌套其他事务
 - PROPAGATION_SUPPORTS;——————如果没有，以非事务方式执行;如果有，就使用当前事务
 - PROPAGATION_NOT_SUPPORTED;——————如果没有，以非事务方式执行;如果有，将当前事务挂起
 - PROPAGATION_NEVER;——————如果没有。以非事务方式执行;如果有，就抛出异常
 - PROPAGATION_MANDATORY.——————如果没有，就抛出异常;如果有，就使用当前事务
 
 
 
 
 
 

